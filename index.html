<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üèÜ PONG ROUND OF 16 üèÜ</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: 'Arial', sans-serif;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      height: 100vh;
    }
    #gameContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d, purple, lightgreen);
      background-size: 400% 400%;
      animation: gradientBG 15s ease infinite;
      display: block;
      touch-action: none;
      width: 100%;
      height: 100%;
    }
    @keyframes gradientBG {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #leftScore, #rightScore {
      position: absolute;
      top: 20px;
      font-size: 3rem;
      color: white;
      text-shadow: 0 0 10px rgba(255,255,255,0.7);
    }
    #leftScore { left: 25%; }
    #rightScore { right: 25%; }
    #timer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2rem;
      color: white;
    }
    #bonusPoints {
      position: absolute;
      top: 80px;
      right: 20px;
      color: gold;
      font-size: 1.5rem;
      text-shadow: 1px 1px 2px black;
    }
    #commentary {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      max-width: 90%;
      text-align: center;
      font-size: 1.2rem;
    }
    #titleScreen, #endScreen, #lobbyScreen, #createGameScreen, #findGameScreen, #waitingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #titleScreen h1, #endScreen h1, #lobbyScreen h1, #createGameScreen h1, #findGameScreen h1 {
      font-size: 2.5rem;
      color: gold;
      text-shadow: 0 0 10px rgba(255,215,0,0.7);
      margin-bottom: 1.5rem;
      text-align: center;
    }
    #titleScreen h2, #lobbyScreen h2 {
      font-size: 1.8rem;
      color: white;
      margin-bottom: 1.5rem;
    }
    .btn-championship {
      background: linear-gradient(45deg, #ff8a00, #e52e71);
      border: none;
      font-size: 1.2rem;
      padding: 8px 20px;
      margin: 8px;
      border-radius: 50px;
      color: white;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transition: all 0.3s;
    }
    .btn-championship:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
    }
    #muteButton, #pauseButton {
      position: absolute;
      top: 15px;
      z-index: 20;
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
    }
    #muteButton { left: 15px; }
    #pauseButton { left: 65px; }
    #pauseScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 15;
      color: white;
      font-size: 2rem;
    }
    #countdown {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 25;
      color: white;
      font-size: 5rem;
      font-weight: bold;
    }
    #playerNameInput {
      padding: 8px;
      font-size: 1.2rem;
      margin-bottom: 15px;
      width: 250px;
      text-align: center;
      border-radius: 20px;
      border: none;
    }
    #gameList {
      width: 90%;
      max-height: 50vh;
      overflow-y: auto;
      margin: 15px 0;
    }
    .game-item {
      background: rgba(255,255,255,0.1);
      padding: 12px;
      margin: 8px 0;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1.1rem;
    }
    .game-item:hover {
      background: rgba(255,255,255,0.2);
    }
    #refreshButton {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
    }
    #waitingMessage {
      font-size: 1.2rem;
      color: white;
      margin-bottom: 15px;
      text-align: center;
    }
    /* Mobile Controls */
    #leftControls, #rightControls {
      position: absolute;
      bottom: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 5;
    }
    #leftControls { left: 20px; }
    #rightControls { right: 20px; }
    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 5px;
      font-size: 1.5rem;
      color: white;
      user-select: none;
    }
    .control-btn:active {
      background: rgba(255,255,255,0.5);
    }
    /* Confetti styles */
    .confetti {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: #f00;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
    }
    @keyframes confetti-fall {
      0% { transform: translateY(-100px) rotate(0deg); }
      100% { transform: translateY(100vh) rotate(360deg); }
    }
    @media (max-width: 768px) {
      #leftScore, #rightScore { font-size: 1.8rem; top: 10px; }
      #timer { font-size: 1.2rem; top: 10px; }
      #bonusPoints { font-size: 1rem; top: 50px; }
      #commentary { font-size: 0.9rem; padding: 6px 12px; }
      .btn-championship { font-size: 1rem; padding: 6px 15px; }
      #titleScreen h1, #lobbyScreen h1 { font-size: 2rem; }
      #titleScreen h2, #lobbyScreen h2 { font-size: 1.5rem; }
      #playerNameInput { width: 200px; font-size: 1rem; }
      .game-item { font-size: 1rem; padding: 10px; }
      .control-btn { width: 50px; height: 50px; font-size: 1.2rem; }
    }
    @media (max-height: 500px) {
      #titleScreen h1, #lobbyScreen h1 { font-size: 1.8rem; }
      #titleScreen h2, #lobbyScreen h2 { font-size: 1.3rem; }
      .btn-championship { font-size: 0.9rem; padding: 5px 12px; }
      #leftControls, #rightControls { bottom: 15px; }
      .control-btn { width: 45px; height: 45px; font-size: 1.1rem; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="pongCanvas"></canvas>
    
    <!-- Mobile Controls -->
    <div id="leftControls">
      <div class="control-btn" id="upBtnLeft">‚Üë</div>
      <div class="control-btn" id="downBtnLeft">‚Üì</div>
    </div>
    <div id="rightControls">
      <div class="control-btn" id="upBtnRight">‚Üë</div>
      <div class="control-btn" id="downBtnRight">‚Üì</div>
    </div>
    
    <div id="leftScore">0</div>
    <div id="rightScore">0</div>
    <div id="timer">2:00.000</div>
    <div id="bonusPoints"></div>
    <div id="commentary">WELCOME TO THE PONG ROUND OF 16!</div>
    <button id="muteButton">üîä</button>
    <button id="pauseButton">‚è∏Ô∏è</button>

    <!-- Audio Elements -->
    <audio id="menuMusic" loop>
      <source src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-668.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameMusic" loop>
      <source src="https://assets.mixkit.co/music/preview/mixkit-arcade-retro-game-over-213.mp3" type="audio/mpeg">
    </audio>

    <!-- Countdown Screen -->
    <div id="countdown"></div>

    <!-- Pause Screen -->
    <div id="pauseScreen">
      <h1>GAME PAUSED</h1>
      <p>Press ‚è∏Ô∏è to continue</p>
      <button class="btn-championship" onclick="returnToMenu()">RETURN TO MENU</button>
    </div>

    <!-- Title Screen -->
    <div id="titleScreen">
      <h1>üèÜ PONG ROUND OF 16 üèÜ</h1>
      <h2>First Match</h2>
      <button class="btn-championship" onclick="startGame(false)">2 PLAYERS</button>
      <button class="btn-championship" onclick="startGame(true)">4 PLAYERS</button>
      <button class="btn-championship" onclick="showLobbyScreen()">ONLINE PLAY</button>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen" style="display: none;">
      <h1>ONLINE MULTIPLAYER</h1>
      <h2>Select an option</h2>
      <button class="btn-championship" onclick="showCreateGameScreen()">CREATE A GAME</button>
      <button class="btn-championship" onclick="showFindGameScreen()">FIND A GAME</button>
      <button class="btn-championship" onclick="returnToTitleScreen()">BACK</button>
    </div>

    <!-- Create Game Screen -->
    <div id="createGameScreen" style="display: none;">
      <h1>CREATE GAME</h1>
      <input type="text" id="hostNameInput" placeholder="Enter your name" maxlength="20">
      <button class="btn-championship" onclick="createGame()">START GAME</button>
      <button class="btn-championship" onclick="returnToLobbyScreen()">BACK</button>
    </div>

    <!-- Find Game Screen -->
    <div id="findGameScreen" style="display: none;">
      <h1>FIND GAME</h1>
      <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
      <div id="gameList"></div>
      <button id="refreshButton" onclick="refreshGameList()">üîÑ</button>
      <button class="btn-championship" onclick="returnToLobbyScreen()">BACK</button>
    </div>

    <!-- Waiting Screen -->
    <div id="waitingScreen" style="display: none;">
      <h1>WAITING FOR PLAYER</h1>
      <div id="waitingMessage">Share this code with your friend: <span id="gameCode"></span></div>
      <button class="btn-championship" onclick="cancelWaiting()">CANCEL</button>
    </div>

    <!-- End Screen -->
    <div id="endScreen" style="display: none;">
      <h1 id="endMessage" style="color: gold; font-size: 2rem;"></h1>
      <button class="btn-championship" onclick="returnToMenu()">RETURN TO MENU</button>
      <button class="btn-championship" onclick="restartGame()">PLAY AGAIN</button>
    </div>
  </div>

  <!-- Bootstrap JS + Popper -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- PeerJS for WebRTC -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

  <script>
    // ===== GAME CONSTANTS =====
    const PADDLE_HEIGHT = 120;
    const PADDLE_WIDTH = 15;
    const FOUR_PLAYER_PADDLE_HEIGHT = 180;
    const BALL_RADIUS = 10;
    const INITIAL_BALL_SPEED = 10;
    const FOUR_PLAYER_BALL_SPEED = 8;
    const PADDLE_SPEED = 8;
    const WINNING_SCORE = 10;
    const GAME_TIME = 120; // 2 minutes in seconds
    const OVERTIME_TIME = 30; // 30 seconds overtime
    const canvas = document.getElementById('pongCanvas');
    const ctx = canvas.getContext('2d');
    const leftScoreEl = document.getElementById('leftScore');
    const rightScoreEl = document.getElementById('rightScore');
    const timerEl = document.getElementById('timer');
    const bonusPointsEl = document.getElementById('bonusPoints');
    const commentaryEl = document.getElementById('commentary');
    const muteBtn = document.getElementById('muteButton');
    const pauseBtn = document.getElementById('pauseButton');
    const pauseScreen = document.getElementById('pauseScreen');
    const countdownEl = document.getElementById('countdown');
    const titleScreen = document.getElementById('titleScreen');
    const endScreen = document.getElementById('endScreen');
    const endMessage = document.getElementById('endMessage');
    const lobbyScreen = document.getElementById('lobbyScreen');
    const createGameScreen = document.getElementById('createGameScreen');
    const findGameScreen = document.getElementById('findGameScreen');
    const waitingScreen = document.getElementById('waitingScreen');
    const hostNameInput = document.getElementById('hostNameInput');
    const playerNameInput = document.getElementById('playerNameInput');
    const gameList = document.getElementById('gameList');
    const gameCodeEl = document.getElementById('gameCode');
    const waitingMessage = document.getElementById('waitingMessage');
    const menuMusic = document.getElementById('menuMusic');
    const gameMusic = document.getElementById('gameMusic');
    const upBtnLeft = document.getElementById('upBtnLeft');
    const downBtnLeft = document.getElementById('downBtnLeft');
    const upBtnRight = document.getElementById('upBtnRight');
    const downBtnRight = document.getElementById('downBtnRight');

    // PeerJS connection variables
    let peer;
    let conn;
    let peerId;
    let isHost = false;
    let currentGameId = null;
    let peerList = {};

    // ===== GAME STATE =====
    let game = {
      ball: { x: 0, y: 0, dx: 0, dy: 0, speed: INITIAL_BALL_SPEED },
      leftPaddle: { y: 0, score: 0 },
      rightPaddle: { y: 0, score: 0 },
      leftTopPaddle: { y: 0 },
      leftBottomPaddle: { y: 0 },
      rightTopPaddle: { y: 0 },
      rightBottomPaddle: { y: 0 },
      isFourPlayer: false,
      isMuted: false,
      isPaused: false,
      gameStarted: false,
      remainingTime: GAME_TIME,
      lastScorer: null,
      matchPoint: false,
      leftPlayer: "PLAYER ONE",
      rightPlayer: "PLAYER TWO",
      timerInterval: null,
      countdownInterval: null,
      keysPressed: {},
      bonusPoints: 0,
      deuceActive: false,
      startTime: 0,
      elapsedPausedTime: 0,
      pausedTime: 0,
      tournamentRound: "Round of 16",
      commentaryQueue: [],
      isSpeaking: false,
      hasAnnounced30: false,
      hasAnnounced10: false,
      activeTouches: {},
      currentUtterance: null,
      lastSpecialMoveTime: 0,
      betweenPointsTimeout: null,
      touchControls: {
        leftTop: false,
        leftBottom: false,
        rightTop: false,
        rightBottom: false
      },
      isOnlineGame: false,
      playerPosition: null, // 'left' or 'right'
      mobileControls: {
        leftUp: false,
        leftDown: false,
        rightUp: false,
        rightDown: false
      }
    };

    // ===== COMMENTARY SYSTEM =====
    const commentaryPhrases = {
      introductions: [
        "Welcome to the Pong Championship!",
        "Get ready for an epic Pong battle!",
        "The crowd is buzzing for this match!"
      ],
      playerIntroductions: [
        "On the left we have {leftPlayer}, and on the right {rightPlayer}",
        "Two titans of Pong face off today: {leftPlayer} versus {rightPlayer}",
        "Let's meet our competitors: {leftPlayer} and {rightPlayer}"
      ],
      countdown: [
        "The match is about to begin!",
        "Players take your positions!",
        "Here we go!"
      ],
      scores: [
        "Point to {player}!",
        "{player} scores!",
        "What a shot by {player}!"
      ],
      deuce: [
        "We're at deuce! Bonus point activated!",
        "Tied up! Next point wins!",
        "It's anyone's game now!"
      ],
      matchPoint: [
        "Match point for {player}!",
        "{player} is one point away from victory!",
        "Can {player} close it out here?"
      ],
      timeWarnings: [
        "Only 30 seconds remaining!",
        "The clock is ticking down!",
        "Time is running out!"
      ],
      overtime: [
        "We're going to overtime!",
        "Sudden death overtime begins now!",
        "Next point wins in overtime!"
      ],
      victories: [
        "What a performance!",
        "Absolutely dominant play!",
        "A well-earned victory!"
      ],
      specialMoves: [
        "Incredible shot!",
        "That was spectacular!",
        "Unbelievable play!"
      ],
      betweenPoints: [
        "The tension is palpable!",
        "Who will take the lead?",
        "This match is heating up!"
      ],
      reactions: [
        "Amazing!",
        "Wow!",
        "Incredible!"
      ]
    };

    function getRandomCommentary(type) {
      const phrases = commentaryPhrases[type];
      if (!phrases) return "";
      
      let phrase = phrases[Math.floor(Math.random() * phrases.length)];
      phrase = phrase.replace(/{leftPlayer}/g, game.leftPlayer);
      phrase = phrase.replace(/{rightPlayer}/g, game.rightPlayer);
      phrase = phrase.replace(/{player}/g, game.lastScorer || "the player");
      
      return phrase;
    }

    function queueCommentary(text, important = false) {
      if (important) {
        game.commentaryQueue.unshift(text);
      } else {
        game.commentaryQueue.push(text);
      }
      
      if (!game.isSpeaking) {
        speakNextCommentary();
      }
    }

    function announceCommentary(text, important = false) {
      commentaryEl.textContent = text;
      
      if (!game.isMuted) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.9;
        utterance.pitch = 1.2;
        
        utterance.onend = () => {
          game.isSpeaking = false;
          speakNextCommentary();
        };
        
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
        game.isSpeaking = true;
      }
    }

    function speakNextCommentary() {
      if (game.commentaryQueue.length > 0 && !game.isSpeaking) {
        const text = game.commentaryQueue.shift();
        announceCommentary(text);
      }
    }

    function checkForSpecialMove() {
      // Check if ball speed is very high (special move)
      const speedThreshold = game.isFourPlayer ? FOUR_PLAYER_BALL_SPEED * 1.8 : INITIAL_BALL_SPEED * 1.8;
      const now = Date.now();
      
      if (game.ball.speed >= speedThreshold && now - game.lastSpecialMoveTime > 5000) {
        game.lastSpecialMoveTime = now;
        return true;
      }
      return false;
    }

    // ===== MOBILE CONTROLS =====
    function setupMobileControls() {
      // Left controls
      upBtnLeft.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.mobileControls.leftUp = true;
      });
      upBtnLeft.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.mobileControls.leftUp = false;
      });
      downBtnLeft.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.mobileControls.leftDown = true;
      });
      downBtnLeft.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.mobileControls.leftDown = false;
      });

      // Right controls
      upBtnRight.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.mobileControls.rightUp = true;
      });
      upBtnRight.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.mobileControls.rightUp = false;
      });
      downBtnRight.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.mobileControls.rightDown = true;
      });
      downBtnRight.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.mobileControls.rightDown = false;
      });

      // Mouse controls for testing on desktop
      upBtnLeft.addEventListener('mousedown', () => game.mobileControls.leftUp = true);
      upBtnLeft.addEventListener('mouseup', () => game.mobileControls.leftUp = false);
      downBtnLeft.addEventListener('mousedown', () => game.mobileControls.leftDown = true);
      downBtnLeft.addEventListener('mouseup', () => game.mobileControls.leftDown = false);
      upBtnRight.addEventListener('mousedown', () => game.mobileControls.rightUp = true);
      upBtnRight.addEventListener('mouseup', () => game.mobileControls.rightUp = false);
      downBtnRight.addEventListener('mousedown', () => game.mobileControls.rightDown = true);
      downBtnRight.addEventListener('mouseup', () => game.mobileControls.rightDown = false);
    }

    // ===== PEERJS INITIALIZATION =====
    function initializePeerJS() {
      // Create a new Peer with a random ID
      peer = new Peer({
        config: {'iceServers': [
          { url: 'stun:stun.l.google.com:19302' },
          { url: 'stun:global.stun.twilio.com:3478?transport=udp' }
        ]}
      });

      peer.on('open', (id) => {
        peerId = id;
        console.log('My peer ID is: ' + id);
      });

      peer.on('connection', (connection) => {
        conn = connection;
        console.log('Connected to: ' + connection.peer);
        
        conn.on('open', () => {
          console.log('Connection established');
          // If we're the host, we're the left player
          if (isHost) {
            game.playerPosition = 'left';
            game.leftPlayer = hostNameInput.value || "HOST PLAYER";
            waitingScreen.style.display = 'none';
            startOnlineGame();
          }
        });

        conn.on('data', (data) => {
          handlePeerData(data);
        });

        conn.on('close', () => {
          console.log('Connection closed');
          if (game.gameStarted) {
            announceCommentary("Opponent disconnected!", true);
            endGame();
          }
        });
      });

      peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        announceCommentary("Connection error occurred", true);
      });
    }

    function handlePeerData(data) {
      if (data.type === 'paddleMove') {
        // Update the opponent's paddle position
        if (game.playerPosition === 'left') {
          game.rightPaddle.y = data.y;
        } else {
          game.leftPaddle.y = data.y;
        }
      } else if (data.type === 'ballUpdate') {
        // Sync ball position (host sends to client)
        game.ball = data.ball;
      } else if (data.type === 'scoreUpdate') {
        // Update scores
        game.leftPaddle.score = data.leftScore;
        game.rightPaddle.score = data.rightScore;
        leftScoreEl.textContent = game.leftPaddle.score;
        rightScoreEl.textContent = game.rightPaddle.score;
      } else if (data.type === 'gameStart') {
        // Client receives game start info
        game.rightPlayer = data.rightPlayer || "OPPONENT";
        game.playerPosition = 'right';
        startOnlineGame();
      } else if (data.type === 'gameEnd') {
        endGame();
      }
    }

    function sendPaddlePosition() {
      if (conn && conn.open) {
        const y = game.playerPosition === 'left' ? game.leftPaddle.y : game.rightPaddle.y;
        conn.send({ type: 'paddleMove', y: y });
      }
    }

    function sendBallUpdate() {
      if (conn && conn.open && isHost) {
        conn.send({ type: 'ballUpdate', ball: game.ball });
      }
    }

    function sendScoreUpdate() {
      if (conn && conn.open && isHost) {
        conn.send({ 
          type: 'scoreUpdate', 
          leftScore: game.leftPaddle.score,
          rightScore: game.rightPaddle.score
        });
      }
    }

    // ===== ONLINE GAME FUNCTIONS =====
    function showLobbyScreen() {
      titleScreen.style.display = 'none';
      lobbyScreen.style.display = 'flex';
      initializePeerJS();
    }

    function returnToLobbyScreen() {
      createGameScreen.style.display = 'none';
      findGameScreen.style.display = 'none';
      lobbyScreen.style.display = 'flex';
    }

    function returnToTitleScreen() {
      lobbyScreen.style.display = 'none';
      titleScreen.style.display = 'flex';
      if (peer) peer.destroy();
    }

    function showCreateGameScreen() {
      lobbyScreen.style.display = 'none';
      createGameScreen.style.display = 'flex';
      hostNameInput.focus();
    }

    function showFindGameScreen() {
      lobbyScreen.style.display = 'none';
      findGameScreen.style.display = 'flex';
      playerNameInput.focus();
      refreshGameList();
    }

    function createGame() {
      const playerName = hostNameInput.value.trim();
      if (!playerName) {
        alert("Please enter your name");
        return;
      }
      
      isHost = true;
      currentGameId = peerId;
      gameCodeEl.textContent = peerId;
      createGameScreen.style.display = 'none';
      waitingScreen.style.display = 'flex';
      waitingMessage.textContent = `Share this code with your friend: ${peerId}`;
      
      // Store game in "available games" list
      const gameInfo = {
        id: peerId,
        name: `${playerName}'s Game`,
        timestamp: Date.now()
      };
      addGameToDiscoveryList(gameInfo);
      
      game.leftPlayer = playerName;
      game.rightPlayer = "Waiting...";
    }

    function refreshGameList() {
      gameList.innerHTML = '<div style="color: white; text-align: center;">Searching for games...</div>';
      
      // In a real app, you would query a server here
      // For this demo, we'll use localStorage to simulate game discovery
      setTimeout(() => {
        const games = getAvailableGames();
        
        if (games.length === 0) {
          gameList.innerHTML = '<div style="color: white; text-align: center;">No games found. Try refreshing.</div>';
        } else {
          gameList.innerHTML = '';
          games.forEach(game => {
            const gameItem = document.createElement('div');
            gameItem.className = 'game-item';
            gameItem.innerHTML = `
              <div><strong>${game.name}</strong></div>
              <div>Code: ${game.id}</div>
            `;
            gameItem.onclick = () => joinGame(game.id);
            gameList.appendChild(gameItem);
          });
        }
      }, 1000);
    }

    // Simulate game discovery using localStorage
    function addGameToDiscoveryList(gameInfo) {
      const games = JSON.parse(localStorage.getItem('pongGames')) || [];
      // Remove old games (older than 5 minutes)
      const now = Date.now();
      const freshGames = games.filter(g => now - g.timestamp < 300000);
      freshGames.push(gameInfo);
      localStorage.setItem('pongGames', JSON.stringify(freshGames));
    }

    function getAvailableGames() {
      const games = JSON.parse(localStorage.getItem('pongGames')) || [];
      // Filter out games older than 5 minutes
      const now = Date.now();
      return games.filter(g => now - g.timestamp < 300000);
    }

    function joinGame(gameId) {
      const playerName = playerNameInput.value.trim();
      if (!playerName) {
        alert("Please enter your name");
        return;
      }
      
      if (!peerId) {
        alert("Connection not ready yet. Please wait a moment and try again.");
        return;
      }
      
      // Connect to the host
      conn = peer.connect(gameId);
      
      conn.on('open', () => {
        console.log('Connected to host');
        game.rightPlayer = playerName;
        findGameScreen.style.display = 'none';
        
        // Tell host we're joining
        conn.send({ 
          type: 'gameStart',
          rightPlayer: playerName
        });
      });
      
      conn.on('data', (data) => {
        handlePeerData(data);
      });
      
      conn.on('close', () => {
        console.log('Connection to host closed');
        if (game.gameStarted) {
          announceCommentary("Host disconnected!", true);
          endGame();
        }
      });
      
      conn.on('error', (err) => {
        console.error('Connection error:', err);
        announceCommentary("Failed to connect to game", true);
      });
    }

    function cancelWaiting() {
      if (conn) conn.close();
      waitingScreen.style.display = 'none';
      lobbyScreen.style.display = 'flex';
      
      // Remove game from discovery list if host cancels
      if (isHost && currentGameId) {
        const games = JSON.parse(localStorage.getItem('pongGames')) || [];
        const updatedGames = games.filter(g => g.id !== currentGameId);
        localStorage.setItem('pongGames', JSON.stringify(updatedGames));
      }
    }

    function startOnlineGame() {
      game.isOnlineGame = true;
      game.isFourPlayer = false; // Online is always 2-player
      
      titleScreen.style.display = "none";
      endScreen.style.display = "none";
      pauseScreen.style.display = "none";
      waitingScreen.style.display = "none";
      resetBall();
      resetPaddles();
      
      leftScoreEl.textContent = "0";
      rightScoreEl.textContent = "0";
      timerEl.textContent = "2:00.000";
      
      // Tournament introductions
      queueCommentary(`In this online match: ${game.leftPlayer} vs ${game.rightPlayer}!`, true);
      setTimeout(() => {
        queueCommentary("The online tournament match is about to begin!", true);
      }, 3000);
      
      startCountdown();
    }

    // ===== GAME INITIALIZATION =====
    function initGame() {
      // Set up responsive design
      handleResize();
      window.addEventListener('resize', handleResize);
      
      // Set up controls
      setupMobileControls();
      setupKeyboardControls();
      
      // Initialize game elements
      resizeCanvas();
      resetBall();
      resetPaddles();
      
      // Set up button event listeners
      muteBtn.addEventListener('click', toggleMute);
      pauseBtn.addEventListener('click', togglePause);
      
      // Start menu music
      try {
        menuMusic.volume = 0.5;
        menuMusic.play().catch(e => console.log("Autoplay prevented:", e));
      } catch (e) {
        console.log("Music error:", e);
      }
      
      // Start game loop
      gameLoop();
    }

    // ===== CANVAS RESIZING =====
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      resetPaddles();
    }

    // ===== RESPONSIVE DESIGN =====
    function handleResize() {
      // Update control button positions for mobile
      const controlMargin = window.innerWidth * 0.05;
      document.getElementById('leftControls').style.left = `${controlMargin}px`;
      document.getElementById('rightControls').style.right = `${controlMargin}px`;
      
      // Adjust control button size based on screen size
      const controlSize = Math.min(60, window.innerWidth * 0.12);
      document.querySelectorAll('.control-btn').forEach(btn => {
        btn.style.width = `${controlSize}px`;
        btn.style.height = `${controlSize}px`;
      });
      
      // Reset game elements after resize
      if (game.gameStarted) {
        resizeCanvas();
        resetPaddles();
        resetBall();
      }
    }

    // ===== PADDLE PHYSICS =====
    function getBallAngle(paddleY, hitY, paddleHeight) {
      const relativeY = (hitY - paddleY) / paddleHeight;
      const normalizedY = (relativeY * 2) - 1;
      return normalizedY * Math.PI / 3;
    }

    // ===== GAME LOOP =====
    function gameLoop() {
      if (!game.gameStarted || game.isPaused) {
        requestAnimationFrame(gameLoop);
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      drawPaddles();
      drawBall();
      drawNet();

      updateBall();
      updatePaddles();
      checkCollisions();

      // Send paddle position to opponent in online games
      if (game.isOnlineGame && game.gameStarted && !game.isPaused) {
        sendPaddlePosition();
      }

      requestAnimationFrame(gameLoop);
    }

    // ===== UPDATE PADDLES =====
    function updatePaddles() {
      if (game.isPaused) return;

      // Mobile controls
      if (game.mobileControls.leftUp) game.leftPaddle.y -= PADDLE_SPEED;
      if (game.mobileControls.leftDown) game.leftPaddle.y += PADDLE_SPEED;
      if (game.mobileControls.rightUp) game.rightPaddle.y -= PADDLE_SPEED;
      if (game.mobileControls.rightDown) game.rightPaddle.y += PADDLE_SPEED;

      // Keyboard controls
      if (!game.isFourPlayer) {
        if (game.isOnlineGame) {
          // Online game controls - only control your own paddle
          if (game.playerPosition === 'left') {
            if (game.keysPressed['w']) game.leftPaddle.y -= PADDLE_SPEED;
            if (game.keysPressed['s']) game.leftPaddle.y += PADDLE_SPEED;
          } else {
            if (game.keysPressed['ArrowUp']) game.rightPaddle.y -= PADDLE_SPEED;
            if (game.keysPressed['ArrowDown']) game.rightPaddle.y += PADDLE_SPEED;
          }
        } else {
          // Local multiplayer controls
          if (game.keysPressed['w']) game.leftPaddle.y -= PADDLE_SPEED;
          if (game.keysPressed['s']) game.leftPaddle.y += PADDLE_SPEED;
          if (game.keysPressed['ArrowUp']) game.rightPaddle.y -= PADDLE_SPEED;
          if (game.keysPressed['ArrowDown']) game.rightPaddle.y += PADDLE_SPEED;
        }
      } 
      // 4-Player Keyboard Controls (not available in online mode)
      else {
        if (game.keysPressed['w']) game.leftTopPaddle.y -= PADDLE_SPEED;
        if (game.keysPressed['s']) game.leftTopPaddle.y += PADDLE_SPEED;
        if (game.keysPressed['q']) game.leftBottomPaddle.y -= PADDLE_SPEED;
        if (game.keysPressed['a']) game.leftBottomPaddle.y += PADDLE_SPEED;
        if (game.keysPressed['o']) game.rightTopPaddle.y -= PADDLE_SPEED;
        if (game.keysPressed['l']) game.rightTopPaddle.y += PADDLE_SPEED;
        if (game.keysPressed['ArrowUp']) game.rightBottomPaddle.y -= PADDLE_SPEED;
        if (game.keysPressed['ArrowDown']) game.rightBottomPaddle.y += PADDLE_SPEED;
      }
      
      constrainPaddles();
    }

    // ===== GAME MECHANICS =====
    function resetBall() {
      game.ball.x = canvas.width / 2;
      game.ball.y = canvas.height / 2;
      game.ball.speed = game.isFourPlayer ? FOUR_PLAYER_BALL_SPEED : INITIAL_BALL_SPEED;
      game.ball.dx = Math.random() > 0.5 ? game.ball.speed : -game.ball.speed;
      game.ball.dy = (Math.random() * 2 - 1) * game.ball.speed;
    }

    function resetPaddles() {
      const paddleHeight = game.isFourPlayer ? FOUR_PLAYER_PADDLE_HEIGHT : PADDLE_HEIGHT;
      const centerY = (canvas.height - paddleHeight) / 2;
      
      game.leftPaddle.y = centerY;
      game.rightPaddle.y = centerY;
      
      if (game.isFourPlayer) {
        // Position top and bottom paddles for 4-player mode
        game.leftTopPaddle.y = canvas.height * 0.25 - paddleHeight/2;
        game.leftBottomPaddle.y = canvas.height * 0.75 - paddleHeight/2;
        game.rightTopPaddle.y = canvas.height * 0.25 - paddleHeight/2;
        game.rightBottomPaddle.y = canvas.height * 0.75 - paddleHeight/2;
      }
    }

    function constrainPaddles() {
      const paddleHeight = game.isFourPlayer ? FOUR_PLAYER_PADDLE_HEIGHT : PADDLE_HEIGHT;
      
      // Constrain main paddles
      game.leftPaddle.y = Math.max(0, Math.min(canvas.height - paddleHeight, game.leftPaddle.y));
      game.rightPaddle.y = Math.max(0, Math.min(canvas.height - paddleHeight, game.rightPaddle.y));
      
      // Constrain 4-player paddles
      if (game.isFourPlayer) {
        game.leftTopPaddle.y = Math.max(0, Math.min(canvas.height/2 - paddleHeight - 10, game.leftTopPaddle.y));
        game.leftBottomPaddle.y = Math.max(canvas.height/2 + 10, Math.min(canvas.height - paddleHeight, game.leftBottomPaddle.y));
        game.rightTopPaddle.y = Math.max(0, Math.min(canvas.height/2 - paddleHeight - 10, game.rightTopPaddle.y));
        game.rightBottomPaddle.y = Math.max(canvas.height/2 + 10, Math.min(canvas.height - paddleHeight, game.rightBottomPaddle.y));
      }
    }

    // ===== DRAWING FUNCTIONS =====
    function drawPaddles() {
      ctx.fillStyle = 'white';
      const paddleHeight = game.isFourPlayer ? FOUR_PLAYER_PADDLE_HEIGHT : PADDLE_HEIGHT;
      
      if (!game.isFourPlayer) {
        // 2-player mode
        ctx.fillRect(20, game.leftPaddle.y, PADDLE_WIDTH, paddleHeight);
        ctx.fillRect(canvas.width - 20 - PADDLE_WIDTH, game.rightPaddle.y, PADDLE_WIDTH, paddleHeight);
      } else {
        // 4-player mode - draw all four paddles
        // Left side paddles (top and bottom)
        ctx.fillRect(20, game.leftTopPaddle.y, PADDLE_WIDTH, paddleHeight);
        ctx.fillRect(20, game.leftBottomPaddle.y, PADDLE_WIDTH, paddleHeight);
        
        // Right side paddles (top and bottom)
        ctx.fillRect(canvas.width - 20 - PADDLE_WIDTH, game.rightTopPaddle.y, PADDLE_WIDTH, paddleHeight);
        ctx.fillRect(canvas.width - 20 - PADDLE_WIDTH, game.rightBottomPaddle.y, PADDLE_WIDTH, paddleHeight);
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(game.ball.x, game.ball.y, BALL_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = 'white';
      ctx.fill();
    }

    function drawNet() {
      ctx.setLineDash([10, 15]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ===== GAME PHYSICS =====
    function updateBall() {
      if (game.isPaused) return;
      
      // In online games, only the host updates the ball position
      if (!game.isOnlineGame || isHost) {
        game.ball.x += game.ball.dx;
        game.ball.y += game.ball.dy;
        
        // Send ball update to client if online
        if (game.isOnlineGame && isHost) {
          sendBallUpdate();
        }
      }

      // Wall collision (handled by all players)
      if (game.ball.y - BALL_RADIUS < 0 || game.ball.y + BALL_RADIUS > canvas.height) {
        game.ball.dy = -game.ball.dy;
      }
    }

    function checkCollisions() {
      if (game.isPaused) return;
      
      const paddleHeight = game.isFourPlayer ? FOUR_PLAYER_PADDLE_HEIGHT : PADDLE_HEIGHT;

      // Collision detection for 2-player mode
      if (!game.isFourPlayer) {
        // Left paddle collision
        if (game.ball.x - BALL_RADIUS < 20 + PADDLE_WIDTH &&
            game.ball.y > game.leftPaddle.y &&
            game.ball.y < game.leftPaddle.y + paddleHeight) {
          const angle = getBallAngle(game.leftPaddle.y, game.ball.y, paddleHeight);
          game.ball.dx = Math.abs(Math.cos(angle)) * game.ball.speed;
          game.ball.dy = Math.sin(angle) * game.ball.speed;
          game.ball.speed *= 1.05;
          game.lastScorer = game.leftPlayer;
        }
        
        // Right paddle collision
        if (game.ball.x + BALL_RADIUS > canvas.width - 20 - PADDLE_WIDTH &&
            game.ball.y > game.rightPaddle.y &&
            game.ball.y < game.rightPaddle.y + paddleHeight) {
          const angle = getBallAngle(game.rightPaddle.y, game.ball.y, paddleHeight);
          game.ball.dx = -Math.abs(Math.cos(angle)) * game.ball.speed;
          game.ball.dy = Math.sin(angle) * game.ball.speed;
          game.ball.speed *= 1.05;
          game.lastScorer = game.rightPlayer;
        }
      }
      
      // Scoring (only host handles scoring in online games)
      if (!game.isOnlineGame || isHost) {
        if (game.ball.x - BALL_RADIUS < 0) {
          game.rightPaddle.score++;
          rightScoreEl.textContent = game.rightPaddle.score;
          game.lastScorer = game.rightPlayer;
          
          if (game.isOnlineGame) {
            sendScoreUpdate();
          }
          
          handleScore();
        }

        if (game.ball.x + BALL_RADIUS > canvas.width) {
          game.leftPaddle.score++;
          leftScoreEl.textContent = game.leftPaddle.score;
          game.lastScorer = game.leftPlayer;
          
          if (game.isOnlineGame) {
            sendScoreUpdate();
          }
          
          handleScore();
        }
      }

      // Deuce system - only activate when scores are tied at 5-5 or higher
      if (game.leftPaddle.score >= 5 && game.rightPaddle.score >= 5 && 
          game.leftPaddle.score === game.rightPaddle.score && !game.deuceActive) {
        game.deuceActive = true;
        game.bonusPoints++;
        bonusPointsEl.textContent = `‚ö° BONUS POINT: +${game.bonusPoints}`;
        queueCommentary(getRandomCommentary('deuce'), true);
      } else if (game.leftPaddle.score !== game.rightPaddle.score) {
        game.deuceActive = false;
      }
    }

    function handleScore() {
      const winningThreshold = WINNING_SCORE + game.bonusPoints;

      // Clear any pending between-points commentary
      if (game.betweenPointsTimeout) {
        clearTimeout(game.betweenPointsTimeout);
        game.betweenPointsTimeout = null;
      }

      // Check for special move commentary first
      if (checkForSpecialMove()) {
        queueCommentary(getRandomCommentary('specialMoves'), true);
      }
      // Then check for match point (using the dynamic winning threshold)
      else if ((game.leftPaddle.score === winningThreshold - 1 || 
               game.rightPaddle.score === winningThreshold - 1) && !game.matchPoint) {
        game.matchPoint = true;
        const leader = game.leftPaddle.score > game.rightPaddle.score ? game.leftPlayer : game.rightPlayer;
        const commentary = getRandomCommentary('matchPoint').replace(/{player}/g, leader);
        queueCommentary(commentary, true);
      }
      // Regular score commentary
      else {
        queueCommentary(getRandomCommentary('scores'));
      }

      // Check for win condition using dynamic threshold
      if (game.leftPaddle.score >= winningThreshold || game.rightPaddle.score >= winningThreshold) {
        // In online game, host tells client the game is over
        if (game.isOnlineGame && isHost) {
          conn.send({ type: 'gameEnd' });
        }
        endGame();
        return;
      }

      // Between points commentary (30% chance)
      if (Math.random() < 0.3) {
        game.betweenPointsTimeout = setTimeout(() => {
          queueCommentary(getRandomCommentary('betweenPoints'));
        }, 1500);
      }

      resetBall();
    }

    // ===== GAME TIMER =====
    function startTimer() {
      if (game.timerInterval) clearInterval(game.timerInterval);
      
      game.hasAnnounced30 = false;
      game.hasAnnounced10 = false;
      game.startTime = Date.now();
      
      game.timerInterval = setInterval(() => {
        if (game.isPaused) return;
        
        const elapsed = Date.now() - game.startTime;
        const remaining = Math.max(0, game.remainingTime * 1000 - elapsed);
        
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        const milliseconds = remaining % 1000;
        
        timerEl.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}.${milliseconds < 100 ? (milliseconds < 10 ? '00' : '0') : ''}${milliseconds}`;
        
        // Only announce once
        if (remaining <= 30000 && !game.hasAnnounced30) {
          game.hasAnnounced30 = true;
          queueCommentary(getRandomCommentary('timeWarnings'), true);
        }
        
        if (remaining <= 10000 && !game.hasAnnounced10) {
          game.hasAnnounced10 = true;
          queueCommentary(getRandomCommentary('timeWarnings').replace('30', '10'), true);
        }
        
        if (remaining <= 0) {
          clearInterval(game.timerInterval);
          handleTimeExpired();
        }
      }, 10);
    }

    function handleTimeExpired() {
      if (game.leftPaddle.score === game.rightPaddle.score) {
        game.remainingTime = OVERTIME_TIME;
        game.hasAnnounced30 = false;
        game.hasAnnounced10 = false;
        if (!game.deuceActive) {
          game.bonusPoints++;
          bonusPointsEl.textContent = `‚ö° BONUS POINT: +${game.bonusPoints}`;
        }
        queueCommentary(getRandomCommentary('overtime'), true);
        startTimer();
      } else {
        // In online game, host tells client the game is over
        if (game.isOnlineGame && isHost) {
          conn.send({ type: 'gameEnd' });
        }
        endGame();
      }
    }

    // ===== CONFETTI EFFECT =====
    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
      
      for (let i = 0; i < 150; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animation = `confetti-fall ${Math.random() * 3 + 2}s linear forwards`;
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        
        // Random size and shape
        const size = Math.random() * 8 + 5;
        confetti.style.width = size + 'px';
        confetti.style.height = size + 'px';
        
        // Random shape (square or circle)
        if (Math.random() > 0.5) {
          confetti.style.borderRadius = '50%';
        } else {
          confetti.style.borderRadius = '0';
        }
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation completes
        setTimeout(() => {
          confetti.remove();
        }, 5000);
      }
    }

    // ===== GAME END =====
    function endGame() {
      game.gameStarted = false;
      clearInterval(game.timerInterval);
      gameMusic.pause();
      menuMusic.play().catch(e => console.log("Menu music play prevented:", e));
      
      let winner, loser, winnerScore, loserScore;
      if (game.leftPaddle.score > game.rightPaddle.score) {
        winner = game.leftPlayer;
        loser = game.rightPlayer;
        winnerScore = game.leftPaddle.score;
        loserScore = game.rightPaddle.score;
      } else {
        winner = game.rightPlayer;
        loser = game.leftPlayer;
        winnerScore = game.rightPaddle.score;
        loserScore = game.leftPaddle.score;
      }
      
      endMessage.textContent = `${winner} WINS ${winnerScore}-${loserScore}! üèÜ`;
      endScreen.style.display = "flex";
      
      // Create confetti effect
      createConfetti();
      
      // Tournament victory announcements
      queueCommentary(`${winner} defeats ${loser} ${winnerScore}-${loserScore}!`, true);
      queueCommentary(getRandomCommentary('victories'), true);
      queueCommentary("What an incredible tournament match we've witnessed today!", true);
    }

    // ===== MUTE TOGGLE =====
    function toggleMute() {
      game.isMuted = !game.isMuted;
      muteBtn.textContent = game.isMuted ? "üîá" : "üîä";
      window.speechSynthesis.cancel();
      
      if (game.isMuted) {
        menuMusic.volume = 0;
        gameMusic.volume = 0;
        announceCommentary("Sound muted", true);
      } else {
        menuMusic.volume = 0.5;
        gameMusic.volume = 0.5;
        announceCommentary("Sound unmuted", true);
      }
    }

    // ===== PAUSE FUNCTIONALITY =====
    function togglePause() {
      game.isPaused = !game.isPaused;
      pauseScreen.style.display = game.isPaused ? "flex" : "none";
      
      if (game.isPaused) {
        // When pausing, store the current time and pause music
        game.pausedTime = Date.now();
        gameMusic.pause();
        announceCommentary("GAME PAUSED", true);
      } else {
        // When unpausing, adjust the start time to account for pause duration
        const pauseDuration = Date.now() - game.pausedTime;
        game.startTime += pauseDuration;
        gameMusic.play().catch(e => console.log("Music play prevented:", e));
        announceCommentary("GAME RESUMED", true);
      }
    }

    function returnToMenu() {
      game.isPaused = false;
      pauseScreen.style.display = "none";
      titleScreen.style.display = "flex";
      clearInterval(game.timerInterval);
      game.gameStarted = false;
      game.isOnlineGame = false;
      gameMusic.pause();
      menuMusic.play().catch(e => console.log("Music play prevented:", e));
      
      // Close any peer connections
      if (conn) conn.close();
      if (peer) peer.destroy();
      
      announceCommentary("RETURNING TO MENU", true);
    }

    // ===== COUNTDOWN FUNCTION =====
    function startCountdown() {
      let count = 3;
      countdownEl.style.display = "flex";
      
      function updateCountdown() {
        if (count > 0) {
          countdownEl.textContent = count;
          if (!game.isMuted) {
            const utterance = new SpeechSynthesisUtterance(count.toString());
            utterance.rate = 0.8;
            utterance.pitch = 1.3;
            window.speechSynthesis.speak(utterance);
          }
          count--;
        } else if (count === 0) {
          countdownEl.textContent = "GO!";
          queueCommentary(getRandomCommentary('reactions'), true);
          if (!game.isMuted) {
            const utterance = new SpeechSynthesisUtterance("GO!");
            utterance.rate = 0.7;
            utterance.pitch = 1.5;
            window.speechSynthesis.speak(utterance);
          }
          count--;
        } else {
          clearInterval(game.countdownInterval);
          countdownEl.style.display = "none";
          game.gameStarted = true;
          game.startTime = Date.now();
          menuMusic.pause();
          gameMusic.play().catch(e => console.log("Game music play prevented:", e));
          startTimer();
        }
      }
      
      updateCountdown();
      game.countdownInterval = setInterval(updateCountdown, 1000);
    }

    // ===== START/RESTART GAME =====
    function startGame(fourPlayerMode) {
      game.isFourPlayer = fourPlayerMode;
      game.isPaused = false;
      game.isOnlineGame = false;
      game.leftPaddle.score = 0;
      game.rightPaddle.score = 0;
      game.remainingTime = GAME_TIME;
      game.matchPoint = false;
      game.bonusPoints = 0;
      game.deuceActive = false;
      game.commentaryQueue = [];
      game.hasAnnounced30 = false;
      game.hasAnnounced10 = false;
      bonusPointsEl.textContent = "";
      game.ball.speed = game.isFourPlayer ? FOUR_PLAYER_BALL_SPEED : INITIAL_BALL_SPEED;

      game.leftPlayer = prompt("Left Player's Name:", "PLAYER ONE") || "PLAYER ONE";
      game.rightPlayer = prompt("Right Player's Name:", "PLAYER TWO") || "PLAYER TWO";

      titleScreen.style.display = "none";
      endScreen.style.display = "none";
      pauseScreen.style.display = "none";
      resetBall();
      resetPaddles();
      
      leftScoreEl.textContent = "0";
      rightScoreEl.textContent = "0";
      timerEl.textContent = "2:00.000";
      
      // Enhanced tournament introductions
      queueCommentary(getRandomCommentary('introductions'), true);
      setTimeout(() => {
        queueCommentary(getRandomCommentary('playerIntroductions'), true);
      }, 3000);
      setTimeout(() => {
        queueCommentary(getRandomCommentary('countdown'), true);
      }, 6000);
      
      startCountdown();
    }

    function restartGame() {
      endScreen.style.display = "none";
      startGame(game.isFourPlayer);
    }

    // ===== KEYBOARD CONTROLS =====
    function setupKeyboardControls() {
      document.addEventListener('keydown', (e) => {
        if (e.key === 'p' || e.key === 'P') {
          togglePause();
        } else if (e.key === 'm' || e.key === 'M') {
          toggleMute();
        } else {
          game.keysPressed[e.key] = true;
        }
      });

      document.addEventListener('keyup', (e) => {
        game.keysPressed[e.key] = false;
      });
    }

    // ===== INITIALIZE GAME =====
    // Wait for DOM to be fully loaded before initializing
    document.addEventListener('DOMContentLoaded', () => {
      initGame();
    });
  </script>
</body>
</html>
